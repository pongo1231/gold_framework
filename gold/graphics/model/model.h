#pragma once

#include "gold/camera.h"
#include "gold/graphics/mesh.h"
#include "gold/graphics/shader_program.h"
#include "gold/memory.h"
#include "gold/util/vector3.h"

#include <string_view>

class gold_texture;

/*
* Model
*/
class gold_model
{
  private:
	gold_unique_ptr<gold_mesh> mesh;
	gold_unique_ptr<gold_shader_program> shader_program;
	gold_vector3 position;
	gold_vector3 rotation;
	gold_vector3 scale { 1.f, 1.f, 1.f };
	gold_ref_ptr<gold_texture> texture;
	float ambient             = .5f;
	float specular_multiplier = 2.f;
	float shininess           = 1.f;

	gold_vector3 box_min;
	gold_vector3 box_max;

  public:
	/*
	* Whether collisions with this model should be physical or only virtual
	* Virtual-only collisions do not affect movement
	*/
	bool is_trigger = false;

	/*
	 * Default constructor, constructs an empty model without a mesh and shader program
	 */
	gold_model() = default;
	/*
	 * Constructs a model
	 * <param name="mesh">Holding pointer for mesh (use std::move)</param>
	 * <param name="shader_program">Holding pointer for shader program (use std::move)</param>
	 */
	gold_model(gold_unique_ptr<gold_mesh> &&mesh, gold_unique_ptr<gold_shader_program> &&shader_program);

	/*
	 * Draw model in world
	 * Can be overriden
	 * <param name="camera">Camera to use as reference for drawing</param>
	 */
	virtual void render(const gold_camera *camera);

	/*
	 * <returns>Shader program used for model</returns>
	 */
	const gold_shader_program *get_shader_program() const;

	/*
	 * Set texture of model
	 * <param name="texture">Reference pointer to texture to use</param>
	 */
	void set_texture(gold_ref_ptr<gold_texture> texture);

	/*
	 * <returns>Position of model</returns>
	 */
	const gold_vector3 &get_position() const;
	/*
	 * Set position of model
	 * <param name="pos">Target position</param>
	 */
	void set_position(const gold_vector3 &pos);

	/*
	 * <returns>Rotation of model</returns>
	 */
	const gold_vector3 &get_rotation() const;
	/*
	 * Set rotation of model
	 * <param name="pos">Target rotation</param>
	 */
	void set_rotation(const gold_vector3 &rotation);

	/*
	 * <returns>Scale of model</returns>
	 */
	const gold_vector3 &get_scale() const;
	/*
	 * Set scale of model
	 * <param name="pos">Target scale</param>
	 */
	void set_scale(const gold_vector3 &scale);

	/*
	 * <returns>Scale + Rotation + Transform matrix of model</returns>
	 */
	glm::mat4 get_model_matrix() const;

	/*
	 * Set phong shading ambient multiplier of model
	 * <param name="ambient">Ambient multiplier</param>
	 */
	void set_ambient_multiplier(float ambient);
	/*
	 * Set phong shading specular multiplier of model
	 * <param name="specular_multiplier">Specular multiplier</param>
	 */
	void set_specular_multiplier(float specular_multiplier);
	/*
	 * Set phong shading shininess multiplier of model
	 * <param name="shininess">Shininess multiplier</param>
	 */
	void set_shininess(float shininess);

	/*
	 * Get autogenerated bounding box of model used for collisions
	 * <param name="min">Reference to vector3 to store min coordinates of bounding box</param>
	 * <param name="max">Reference to vector3 to store max coordinates of bounding box</param>
	 */
	void get_bounding_box(gold_vector3 &min, gold_vector3 &max) const;
	/*
	 * <param name="model">Other model to check</param>
	 * <param name="offset">Offset to apply to current position</param>
	 * <returns>Whether this model's bounding box collides with other model's bounding box with applied offset</returns>
	 */
	bool is_colliding_with(const gold_model &model, const gold_vector3 &offset = {}) const;

	/*
	 * <param name="filename">Path to .obj file</param>
	 * <returns>Holding pointer to created model</returns>
	 */
	static gold_unique_ptr<gold_model> load_from_obj(std::string_view filename);
	/*
	 * <param name="filename">Path to .obj file</param>
	 * <param name="vertex_shader">Path to source GLSL vertex shader file</param>
	 * <param name="fragment_shader">Path to source GLSL fragment shader file</param>
	 * <returns>Holding pointer to created model</returns>
	 */
	static gold_unique_ptr<gold_model> load_from_obj(std::string_view filename,
	                                                 std::string_view vertex_shader,
	                                                 std::string_view fragment_shader);
};